-- Migration: {{ migration_version }}__Create_{{ service.name }}_{{ database.table }}.sql
-- Description: Create {{ database.table }} table for {{ service.description.lower() }}
-- Author: {{ service.author }}
-- Date: {{ migration_date }}
-- Service: {{ service.name | title }}

-- Create {{ database.table }} table
CREATE TABLE {{ database.table }} (
{% for field in fields -%}
    {{ field.name }} {{ field.type }}
    {%- if not field.nullable %} NOT NULL{% endif -%}
    {%- if field.type.startswith('BIGSERIAL') and field.primaryKey %} PRIMARY KEY{% endif -%}
    {%- if field.type.startswith('TIMESTAMP') and 'DEFAULT' in field.type %}{# Already has default in type definition #}{% endif -%}
    {%- if not loop.last %},{% endif %}
    {%- if field.description %} -- {{ field.description }}{% endif %}
{% endfor %}
);

{% if fields | selectattr('primaryKey', 'equalto', true) | selectattr('type', 'not matching', 'BIGSERIAL') | list %}
-- Add primary key constraint if not auto-generated
{% for field in fields if field.primaryKey and not field.type.startswith('BIGSERIAL') -%}
ALTER TABLE {{ database.table }} ADD CONSTRAINT pk_{{ database.table }}_{{ field.name }} PRIMARY KEY ({{ field.name }});
{% endfor %}
{% endif %}

{% if fields | selectattr('foreignKey', 'defined') | list %}
-- Add foreign key constraints
{% for field in fields if field.foreignKey -%}
ALTER TABLE {{ database.table }} 
    ADD CONSTRAINT fk_{{ database.table }}_{{ field.name }} 
    FOREIGN KEY ({{ field.name }}) 
    REFERENCES {{ field.foreignKey.table }}({{ field.foreignKey.field }})
    {%- if field.foreignKey.onDelete %} ON DELETE {{ field.foreignKey.onDelete }}{% endif %};
{% endfor %}
{% endif %}

-- Create indexes for performance optimization
{% for field in fields %}
{% if field.foreignKey %}
-- Index on foreign key column {{ field.name }}
CREATE INDEX idx_{{ database.table }}_{{ field.name }} ON {{ database.table }}({{ field.name }});
{% endif %}

{% if field.javaType == 'String' and field.validation and field.validation.maxLength and field.validation.maxLength <= 255 %}
-- Index on searchable string field {{ field.name }}
CREATE INDEX idx_{{ database.table }}_{{ field.name }}_search ON {{ database.table }}({{ field.name }});
{% endif %}

{% if field.name == 'created_at' %}
-- Index on created_at for time-based queries
CREATE INDEX idx_{{ database.table }}_created_at ON {{ database.table }}(created_at DESC);
{% endif %}

{% if field.name == 'updated_at' %}
-- Index on updated_at for tracking changes
CREATE INDEX idx_{{ database.table }}_updated_at ON {{ database.table }}(updated_at DESC);
{% endif %}
{% endfor %}

{% if operations.customQueries %}
-- Indexes for custom queries
{% for query in operations.customQueries %}
{% if 'WHERE' in query.query.upper() %}
-- Index for custom query: {{ query.name }}
-- Query: {{ query.description }}
{% set where_clause = query.query.upper().split('WHERE')[1].split('ORDER')[0] if 'ORDER' in query.query.upper() else query.query.upper().split('WHERE')[1] %}
{% if 'USER_ID' in where_clause %}
CREATE INDEX IF NOT EXISTS idx_{{ database.table }}_{{ query.name | lower }} ON {{ database.table }}(user_id, created_at DESC);
{% elif 'CATEGORY' in where_clause %}
CREATE INDEX IF NOT EXISTS idx_{{ database.table }}_{{ query.name | lower }} ON {{ database.table }}(category, created_at DESC);
{% endif %}
{% endif %}
{% endfor %}
{% endif %}

-- Add table comment
COMMENT ON TABLE {{ database.table }} IS '{{ service.description }} - {{ database.entity }} entities';

-- Add column comments
{% for field in fields -%}
COMMENT ON COLUMN {{ database.table }}.{{ field.name }} IS '{{ field.description }}';
{% endfor %}

-- Create trigger for updated_at timestamp (if applicable)
{% if fields | selectattr('name', 'equalto', 'updated_at') | list %}
CREATE OR REPLACE FUNCTION update_{{ database.table }}_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_{{ database.table }}_updated_at
    BEFORE UPDATE ON {{ database.table }}
    FOR EACH ROW
    EXECUTE FUNCTION update_{{ database.table }}_updated_at();
{% endif %}

-- Grant permissions (adjust based on your security requirements)
-- GRANT SELECT, INSERT, UPDATE, DELETE ON {{ database.table }} TO vira_app_user;
-- GRANT USAGE, SELECT ON SEQUENCE {{ database.table }}_id_seq TO vira_app_user;

-- Insert default/seed data if needed
{% if testing and testing.testDataSamples %}
-- Sample data for testing (remove in production)
{% for sample in testing.testDataSamples %}
INSERT INTO {{ database.table }} (
    {%- for field in fields if not field.autoGenerated and not field.name in ['created_at', 'updated_at'] -%}
    {{ field.name }}{% if not loop.last %}, {% endif %}
    {%- endfor -%}
) VALUES (
    {%- for field in fields if not field.autoGenerated and not field.name in ['created_at', 'updated_at'] -%}
    {% if field.name in sample -%}
    {% if field.javaType == 'String' %}'{{ sample[field.name] }}'{% else %}{{ sample[field.name] }}{% endif %}
    {%- else -%}
    {% if field.javaType == 'String' %}NULL{% elif field.javaType == 'Long' %}1{% elif field.javaType == 'BigDecimal' %}0.00{% else %}NULL{% endif %}
    {%- endif -%}
    {% if not loop.last %}, {% endif %}
    {%- endfor -%}
);
{% endfor %}
{% endif %}

-- Verify table creation
SELECT 
    table_name, 
    column_name, 
    data_type, 
    is_nullable,
    column_default
FROM information_schema.columns 
WHERE table_name = '{{ database.table }}'
ORDER BY ordinal_position;

-- Performance analysis query (for DBA reference)
-- SELECT 
--     schemaname,
--     tablename,
--     attname,
--     n_distinct,
--     correlation
-- FROM pg_stats 
-- WHERE tablename = '{{ database.table }}';

-- Migration completed successfully
-- Table: {{ database.table }}
-- Columns: {{ fields | length }}
-- Indexes: Created for foreign keys, searchable fields, and timestamps
-- Constraints: Primary key and foreign key constraints applied
-- Triggers: Updated timestamp trigger (if applicable)

-- Next steps:
-- 1. Review and test the migration in development environment
-- 2. Verify all constraints and indexes are working correctly
-- 3. Run performance tests with expected data volume
-- 4. Update application.yml if needed
-- 5. Deploy to production when ready 