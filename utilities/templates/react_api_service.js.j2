/**
 * {{ database.entity }} API Service
 * 
 * Provides API methods for {{ service.description.lower() }}.
 * Handles authentication, error handling, and response transformation.
 * 
 * Generated by Vira Code Generator
 * Service: {{ service.name | title }}
 * Entity: {{ database.entity }}
 * Author: {{ service.author }}
 * Version: {{ service.version }}
 */

import { apiRequest, ApiResponse } from './apiClient';

// Type definitions for {{ database.entity }}
export interface {{ database.entity }}Request {
{% for field in fields if not field.autoGenerated and not field.primaryKey %}
  {{ field.name | camelCase }}{% if not field.validation or not field.validation.required %}?{% endif %}: {% if field.javaType == 'String' %}string{% elif field.javaType == 'Long' or field.javaType == 'Integer' %}number{% elif field.javaType == 'BigDecimal' %}number{% elif field.javaType == 'Boolean' %}boolean{% elif field.javaType == 'LocalDateTime' or field.javaType == 'LocalDate' %}string{% else %}any{% endif %};
{% endfor %}
}

export interface {{ database.entity }}Response {
{% for field in fields %}
  {{ field.name | camelCase }}: {% if field.javaType == 'String' %}string{% elif field.javaType == 'Long' or field.javaType == 'Integer' %}number{% elif field.javaType == 'BigDecimal' %}number{% elif field.javaType == 'Boolean' %}boolean{% elif field.javaType == 'LocalDateTime' or field.javaType == 'LocalDate' %}string{% else %}any{% endif %};
{% endfor %}
}

export interface {{ database.entity }}StatsResponse {
  totalCount: number;
  // Add more statistics fields as needed
}

export interface PaginatedResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  first: boolean;
  last: boolean;
  numberOfElements: number;
}

/**
 * {{ database.entity }} API Service Class
 */
export class {{ database.entity }}ApiService {
  private readonly baseUrl = '{{ api.basePath }}';

{% if operations.create %}
  /**
   * Create a new {{ database.entity.lower() }}
   * 
   * @param data {{ database.entity }} creation data
   * @returns Promise<{{ database.entity }}Response>
   */
  async create{{ database.entity }}(data: {{ database.entity }}Request): Promise<{{ database.entity }}Response> {
    try {
      console.log(`Creating {{ database.entity.lower() }}:`, data);
      
      const response = await apiRequest<ApiResponse<{{ database.entity }}Response>>({
        method: 'POST',
        url: this.baseUrl,
        data,
      });

      if (response.success && response.data) {
        console.log(`{{ database.entity }} created successfully:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to create {{ database.entity.lower() }}');
      }
    } catch (error) {
      console.error(`Error creating {{ database.entity.lower() }}:`, error);
      throw this.handleError(error, 'create {{ database.entity.lower() }}');
    }
  }
{% endif %}

{% if operations.read %}
  /**
   * Get {{ database.entity.lower() }} by ID
   * 
   * @param id {{ database.entity }} ID
   * @returns Promise<{{ database.entity }}Response>
   */
  async get{{ database.entity }}ById(id: {% for field in fields %}{% if field.primaryKey %}{% if field.javaType == 'String' %}string{% else %}number{% endif %}{% endif %}{% endfor %}): Promise<{{ database.entity }}Response> {
    try {
      console.log(`Fetching {{ database.entity.lower() }} with ID:`, id);
      
      const response = await apiRequest<ApiResponse<{{ database.entity }}Response>>({
        method: 'GET',
        url: `${this.baseUrl}/${id}`,
      });

      if (response.success && response.data) {
        console.log(`{{ database.entity }} retrieved successfully:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || '{{ database.entity }} not found');
      }
    } catch (error) {
      console.error(`Error fetching {{ database.entity.lower() }} with ID ${id}:`, error);
      throw this.handleError(error, 'fetch {{ database.entity.lower() }}');
    }
  }
{% endif %}

{% if operations.update %}
  /**
   * Update existing {{ database.entity.lower() }}
   * 
   * @param id {{ database.entity }} ID
   * @param data Update data
   * @returns Promise<{{ database.entity }}Response>
   */
  async update{{ database.entity }}(id: {% for field in fields %}{% if field.primaryKey %}{% if field.javaType == 'String' %}string{% else %}number{% endif %}{% endif %}{% endfor %}, data: Partial<{{ database.entity }}Request>): Promise<{{ database.entity }}Response> {
    try {
      console.log(`Updating {{ database.entity.lower() }} with ID ${id}:`, data);
      
      const response = await apiRequest<ApiResponse<{{ database.entity }}Response>>({
        method: 'PUT',
        url: `${this.baseUrl}/${id}`,
        data,
      });

      if (response.success && response.data) {
        console.log(`{{ database.entity }} updated successfully:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to update {{ database.entity.lower() }}');
      }
    } catch (error) {
      console.error(`Error updating {{ database.entity.lower() }} with ID ${id}:`, error);
      throw this.handleError(error, 'update {{ database.entity.lower() }}');
    }
  }
{% endif %}

{% if operations.delete %}
  /**
   * Delete {{ database.entity.lower() }} by ID
   * 
   * @param id {{ database.entity }} ID
   * @returns Promise<void>
   */
  async delete{{ database.entity }}(id: {% for field in fields %}{% if field.primaryKey %}{% if field.javaType == 'String' %}string{% else %}number{% endif %}{% endif %}{% endfor %}): Promise<void> {
    try {
      console.log(`Deleting {{ database.entity.lower() }} with ID:`, id);
      
      const response = await apiRequest<ApiResponse<string>>({
        method: 'DELETE',
        url: `${this.baseUrl}/${id}`,
      });

      if (response.success) {
        console.log(`{{ database.entity }} deleted successfully`);
      } else {
        throw new Error(response.message || 'Failed to delete {{ database.entity.lower() }}');
      }
    } catch (error) {
      console.error(`Error deleting {{ database.entity.lower() }} with ID ${id}:`, error);
      throw this.handleError(error, 'delete {{ database.entity.lower() }}');
    }
  }
{% endif %}

{% if operations.list %}
  /**
   * Get all {{ database.entity.lower() }}s with pagination
   * 
   * @param page Page number (0-based)
   * @param size Page size
   * @param sortBy Sort field
   * @param sortDirection Sort direction ('asc' | 'desc')
   * @returns Promise<PaginatedResponse<{{ database.entity }}Response>>
   */
  async getAll{{ database.entity }}s(
    page: number = 0,
    size: number = 20,
    sortBy: string = '{% for field in fields %}{% if field.name == 'created_at' %}createdAt{% else %}id{% endif %}{% break %}{% endfor %}',
    sortDirection: 'asc' | 'desc' = 'desc'
  ): Promise<PaginatedResponse<{{ database.entity }}Response>> {
    try {
      console.log(`Fetching {{ database.entity.lower() }}s - page: ${page}, size: ${size}, sort: ${sortBy} ${sortDirection}`);
      
      const params = new URLSearchParams({
        page: page.toString(),
        size: size.toString(),
        sortBy,
        sortDirection,
      });

      const response = await apiRequest<ApiResponse<PaginatedResponse<{{ database.entity }}Response>>>({
        method: 'GET',
        url: `${this.baseUrl}?${params}`,
      });

      if (response.success && response.data) {
        console.log(`{{ database.entity }}s retrieved successfully:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to fetch {{ database.entity.lower() }}s');
      }
    } catch (error) {
      console.error(`Error fetching {{ database.entity.lower() }}s:`, error);
      throw this.handleError(error, 'fetch {{ database.entity.lower() }}s');
    }
  }
{% endif %}

{% if operations.customQueries %}
{% for query in operations.customQueries %}
  /**
   * {{ query.description }}
   * 
   {% for param in query.parameters -%}
   * @param {{ param.split()[-1] }} {{ param.split()[-1] | replace('Id', ' ID') | replace('Date', ' date') }}
   {% endfor -%}
   * @returns Promise<{% if 'List' in query.returnType %}{{ database.entity }}Response[]{% else %}{{ database.entity }}Response{% endif %}>
   */
  async {{ query.name }}(
    {%- for param in query.parameters -%}
    {{ param.split()[-1] }}: {% if 'Long' in param or 'Integer' in param %}number{% elif 'String' in param %}string{% elif 'LocalDateTime' in param or 'LocalDate' in param %}string{% else %}any{% endif %}{% if not loop.last %}, {% endif %}
    {%- endfor -%}
  ): Promise<{% if 'List' in query.returnType %}{{ database.entity }}Response[]{% else %}{{ database.entity }}Response{% endif %}> {
    try {
      console.log(`Executing {{ query.name }} with parameters:`, { 
        {%- for param in query.parameters -%}
        {{ param.split()[-1] }}{% if not loop.last %}, {% endif %}
        {%- endfor -%}
      });
      
      const params = new URLSearchParams({
        {%- for param in query.parameters -%}
        {{ param.split()[-1] }}: {{ param.split()[-1] }}.toString(){% if not loop.last %},{% endif %}
        {%- endfor -%}
      });

      const response = await apiRequest<ApiResponse<{% if 'List' in query.returnType %}{{ database.entity }}Response[]{% else %}{{ database.entity }}Response{% endif %}>>({
        method: 'GET',
        url: `${this.baseUrl}/{{ query.name | replace('findBy', '').lower() }}?${params}`,
      });

      if (response.success && response.data) {
        console.log(`{{ query.name }} results:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to execute {{ query.name }}');
      }
    } catch (error) {
      console.error(`Error executing {{ query.name }}:`, error);
      throw this.handleError(error, '{{ query.name }}');
    }
  }

{% endfor %}
{% endif %}

  /**
   * Get {{ database.entity.lower() }} statistics
   * 
   * @returns Promise<{{ database.entity }}StatsResponse>
   */
  async get{{ database.entity }}Stats(): Promise<{{ database.entity }}StatsResponse> {
    try {
      console.log(`Fetching {{ database.entity.lower() }} statistics`);
      
      const response = await apiRequest<ApiResponse<{{ database.entity }}StatsResponse>>({
        method: 'GET',
        url: `${this.baseUrl}/stats`,
      });

      if (response.success && response.data) {
        console.log(`{{ database.entity }} statistics retrieved:`, response.data);
        return response.data;
      } else {
        throw new Error(response.message || 'Failed to fetch statistics');
      }
    } catch (error) {
      console.error(`Error fetching {{ database.entity.lower() }} statistics:`, error);
      throw this.handleError(error, 'fetch statistics');
    }
  }

  /**
   * Handle API errors with consistent error messages
   * 
   * @param error The error object
   * @param operation The operation that failed
   * @returns Error object
   */
  private handleError(error: any, operation: string): Error {
    if (error.response) {
      // Server responded with error status
      const status = error.response.status;
      const message = error.response.data?.message || error.response.data?.error || 'Unknown server error';
      
      switch (status) {
        case 400:
          return new Error(`Invalid request to ${operation}: ${message}`);
        case 401:
          return new Error(`Authentication required for ${operation}`);
        case 403:
          return new Error(`Permission denied for ${operation}`);
        case 404:
          return new Error(`Resource not found for ${operation}`);
        case 500:
          return new Error(`Server error during ${operation}: ${message}`);
        default:
          return new Error(`Failed to ${operation} (${status}): ${message}`);
      }
    } else if (error.request) {
      // Network error
      return new Error(`Network error during ${operation}. Please check your connection.`);
    } else {
      // Other error
      return new Error(`Error during ${operation}: ${error.message}`);
    }
  }

  /**
   * Validate {{ database.entity }} request data
   * 
   * @param data Request data to validate
   * @returns Validation result
   */
  validate{{ database.entity }}Request(data: {{ database.entity }}Request): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    {% for field in fields if not field.autoGenerated and not field.primaryKey -%}
    {% if field.validation and field.validation.required -%}
    // Validate {{ field.name | replace('_', ' ') }}
    if (!data.{{ field.name | camelCase }}) {
      errors.push('{{ field.name | replace('_', ' ') | title }} is required');
    }
    {% endif -%}
    
    {% if field.javaType == 'String' and field.validation and field.validation.maxLength -%}
    if (data.{{ field.name | camelCase }} && data.{{ field.name | camelCase }}.length > {{ field.validation.maxLength }}) {
      errors.push('{{ field.name | replace('_', ' ') | title }} cannot exceed {{ field.validation.maxLength }} characters');
    }
    {% endif -%}
    
    {% if field.javaType in ['BigDecimal', 'Integer', 'Long'] and field.validation and field.validation.min is defined -%}
    if (data.{{ field.name | camelCase }} !== undefined && data.{{ field.name | camelCase }} < {{ field.validation.min }}) {
      errors.push('{{ field.name | replace('_', ' ') | title }} must be at least {{ field.validation.min }}');
    }
    {% endif -%}
    {% endfor %}

    return { valid: errors.length === 0, errors };
  }

  /**
   * Format {{ database.entity.lower() }} for display
   * 
   * @param {{ database.entity | camelCase }} {{ database.entity }} response
   * @returns Formatted display string
   */
  format{{ database.entity }}Display({{ database.entity | camelCase }}: {{ database.entity }}Response): string {
    {% for field in fields if field.javaType == 'String' and not field.primaryKey -%}
    return `{{ database.entity }} #${{{ database.entity | camelCase }}.{% for f in fields if f.primaryKey %}{{ f.name | camelCase }}{% endfor %}} - ${{{ database.entity | camelCase }}.{{ field.name | camelCase }}}`;
    {% break -%}
    {% else -%}
    return `{{ database.entity }} #${{{ database.entity | camelCase }}.{% for f in fields if f.primaryKey %}{{ f.name | camelCase }}{% endfor %}}`;
    {% endfor %}
  }

  /**
   * Convert {{ database.entity }} response to request format (for editing)
   * 
   * @param response {{ database.entity }} response
   * @returns {{ database.entity }} request
   */
  responseToRequest(response: {{ database.entity }}Response): {{ database.entity }}Request {
    return {
      {% for field in fields if not field.autoGenerated and not field.primaryKey -%}
      {{ field.name | camelCase }}: response.{{ field.name | camelCase }}{% if not loop.last %},{% endif %}
      {% endfor %}
    };
  }
}

// Export singleton instance
export const {{ database.entity | camelCase }}ApiService = new {{ database.entity }}ApiService();

// Export default for easier importing
export default {{ database.entity | camelCase }}ApiService; 